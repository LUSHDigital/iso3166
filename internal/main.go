// this file is used to retrieve the version of the ISO country codes from
// the datasource named id rawFile.
// the iso.go file is then generated.
package main

import (
	"bytes"
	"encoding/json"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"text/template"
	"time"
)

const rawFile = "https://datahub.io/core/country-list/r/data.json"
const textFile = "latest_iso.txt"

type ISOSource []struct {
	Code string
	Name string
}

var client = &http.Client{
	Timeout: 5 * time.Second,
}
var tpl = `
// Code generated by "make build"; DO NOT EDIT.

package iso3166

const (
	{{range $k, $v := .}}
		// {{$v.Name }}
		{{ $v.Code }} ISO31661Alpha2 = "{{$v.Code }}"
	{{end -}}
)
type ISO31661Alpha2 string

func (i ISO31661Alpha2) String() string {
	return string(i)
}

var ValidCodes = []ISO31661Alpha2{
	{{range $k, $v := .}}
		{{- $v.Code -}},
	{{end -}}
}
`

func main() {
	// request the raw file
	resp, err := client.Get(rawFile)
	if err != nil {
		log.Printf("error connecting to datahub: %v", err)
	}
	// read it
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Printf("error reading response body: %v", err)
	}
	defer resp.Body.Close()

	var source ISOSource
	if err := json.Unmarshal(b, &source); err != nil {
		log.Fatalf("cannot unmarshal json: %v", err)
	}

	// execute the template into a buffer
	var buf bytes.Buffer
	t := template.Must(template.New("iso").Parse(tpl))
	if err := t.Execute(&buf, source); err != nil {
		log.Fatal(err)
	}

	// format the new source code
	byt, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("error formatting source: %v", err)
	}

	// create the outfile
	outfile, err := os.Create("../iso.go")
	if err != nil {
		log.Printf("error opening outfile: %v", err)
	}

	// write it to disk
	if _, err := outfile.Write(byt); err != nil {
		log.Printf("error writing to disk: %v", err)
	}
}
